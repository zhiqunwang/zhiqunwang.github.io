[{"title":"Hello World","url":"/2020/05/13/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"Spring Bean工厂后置处理器的使用和原理","url":"/2018/10/04/Spring Bean工厂后置处理器的使用和原理/","content":"\n\n\nSpring Bean工厂即BeanFactoryPostProcessor。在spring 容器初始化的过程中扮演者重要的角色，其作用正如其名，Spring Bean工厂后置处理器。在Spring 容器注册、加载完bean定义后，在bean初始化之前嵌入的处理器。我们可以通过通过实现BeanDefinitionRegistryPostProcessor或者BeanFactoryPostProcessor来改变容器的行为或者属性，比如加入自定义的BeanDefinition、ImportSelector的实现都是基于此。充分体现了spring框架的“open-close”原则。\n\n![image-20200514111933757](../img/image-20200514111933757.png)\n\n#### BeanFactoryPostProcessor定义\n\n在IOC容器标准初始化后，所谓标准初始化就是所有的bean definitions已经被加载但是还未实例化。这时允许去覆写或者增加容器中已经加载的bean的属性。\n\n```java\npublic interface BeanFactoryPostProcessor {\n\n\t/**\n\t * Modify the application context's internal bean factory after its standard\n\t * initialization. All bean definitions will have been loaded, but no beans\n\t * will have been instantiated yet. This allows for overriding or adding\n\t * properties even to eager-initializing beans.\n\t * @param beanFactory the bean factory used by the application context\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t */\n\tvoid postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;\n\n}\n```\n\n#### BeanDefinitionRegistryPostProcessor定义\n\n注册后置处理器继承与BeanFactoryPostProcessor，postProcessBeanDefinitionRegistry方法先于BeanFactoryPostProcessor.postProcessBeanFactory执行，允许在容器标准初始化之后向容器中添加自定义的definition。\n\n```java\npublic interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {\n\n\t/**\n\t * Modify the application context's internal bean definition registry after its\n\t * standard initialization. All regular bean definitions will have been loaded,\n\t * but no beans will have been instantiated yet. This allows for adding further\n\t * bean definitions before the next post-processing phase kicks in.\n\t * @param registry the bean definition registry used by the application context\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t */\n\tvoid postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;\n\n}\n```\n\n#### PostProcessorRegistrationDelegate源码分析\n\n![这里写图片描述](../img/20161018133605816.png)\n\n```java\n//参数  beanFactory： 当前容器beanFactory\n//     beanFactoryPostProcessors:当前容器中已经加载的bean工厂后置处理器集合\npublic static void invokeBeanFactoryPostProcessors(\n      ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n\n   // Invoke BeanDefinitionRegistryPostProcessors first, if any.\n   //记录已执行的后置处理器\n   Set<String> processedBeans = new HashSet<String>();\n\t\t//判断当前容器是否是BeanDefinitionRegistry（执行BeanDefinitionRegistryPostProcessor生效的前置条件）\n   if (beanFactory instanceof BeanDefinitionRegistry) {\n      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n      //定义BeanFactory的后置处理器集合\n      List<BeanFactoryPostProcessor> regularPostProcessors = new LinkedList<BeanFactoryPostProcessor>();\n      //定义BeanDefinitionRegistry后置处理器集合\n      List<BeanDefinitionRegistryPostProcessor> registryProcessors = new LinkedList<BeanDefinitionRegistryPostProcessor>();\n\n      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n         //遍历判断是否是BeanDefinitionRegistry后置处理器，如果是 执行 + 加入指定集合\n         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n            BeanDefinitionRegistryPostProcessor registryProcessor =\n                  (BeanDefinitionRegistryPostProcessor) postProcessor;\n            registryProcessor.postProcessBeanDefinitionRegistry(registry);\n            registryProcessors.add(registryProcessor);\n         }\n         else {\n            regularPostProcessors.add(postProcessor);\n         }\n      }\n      // -----------以上处理已经存在于容器中的处理器---------------\n      // Do not initialize FactoryBeans here: We need to leave all regular beans\n      // uninitialized to let the bean factory post-processors apply to them!\n      // Separate between BeanDefinitionRegistryPostProcessors that implement\n      // PriorityOrdered, Ordered, and the rest.\n      //定义当前处理的BeanDefinitionRegistry后置处理器集合\n      List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();\n\n      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n      //获取容器中所有实现BeanDefinitionRegistryPostProcessor的类\n      String[] postProcessorNames =\n            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n      for (String ppName : postProcessorNames) {\n         //是否实现PriorityOrdered\n         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n            //如果实现了，加入currentRegistryProcessors集合\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            //加入已经执行过的bean列表\n            processedBeans.add(ppName);\n         }\n      }\n      //按照优先级进行排序\n      sortPostProcessors(currentRegistryProcessors, beanFactory);\n      registryProcessors.addAll(currentRegistryProcessors);\n      //对排序后的注册后置处理器进行调用\n      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n      currentRegistryProcessors.clear();\n\n      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n     //获取容器中所有实现BeanDefinitionRegistryPostProcessor的类\n      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n      for (String ppName : postProcessorNames) {\n         //是否实现Ordered同时未执行\n         if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n         }\n      }\n      // 同上\n      sortPostProcessors(currentRegistryProcessors, beanFactory);\n      registryProcessors.addAll(currentRegistryProcessors);\n      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n      currentRegistryProcessors.clear();\n\n      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n      //执行所有剩余的普通BeanDefinitionRegistryPostProcessor\n      boolean reiterate = true;\n      while (reiterate) {\n         reiterate = false;\n         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n         for (String ppName : postProcessorNames) {\n            if (!processedBeans.contains(ppName)) {\n               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n               processedBeans.add(ppName);\n               reiterate = true;\n            }\n         }\n         sortPostProcessors(currentRegistryProcessors, beanFactory);\n         registryProcessors.addAll(currentRegistryProcessors);\n         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n         currentRegistryProcessors.clear();\n      }\n\n      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n      //执行BeanFactoryPostProcessor\n      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n   }\n\n   else {\n      // Invoke factory processors registered with the context instance.\n      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n   }\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let the bean factory post-processors apply to them!\n   //获取所有实现BeanFactoryPostProcessor的类\n   String[] postProcessorNames =\n         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n   // Ordered, and the rest.\n   List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();\n   List<String> orderedPostProcessorNames = new ArrayList<String>();\n   List<String> nonOrderedPostProcessorNames = new ArrayList<String>();\n   for (String ppName : postProcessorNames) {\n      if (processedBeans.contains(ppName)) {\n         // skip - already processed in first phase above\n      }\n      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n      }\n      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n         orderedPostProcessorNames.add(ppName);\n      }\n      else {\n         nonOrderedPostProcessorNames.add(ppName);\n      }\n   }\n   //排序并执行实现PriorityOrdered接口的后置处理器\n   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n   //排序并执行实现Ordered接口的后置处理器\n   List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();\n   for (String postProcessorName : orderedPostProcessorNames) {\n      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   }\n   sortPostProcessors(orderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n   // Finally, invoke all other BeanFactoryPostProcessors.\n  //执行未实现优先级接口的后置处理器\n   List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();\n   for (String postProcessorName : nonOrderedPostProcessorNames) {\n      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   }\n   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n   // Clear cached merged bean definitions since the post-processors might have\n   // modified the original metadata, e.g. replacing placeholders in values...\n   beanFactory.clearMetadataCache();\n}\n```\n\n\n\n","tags":["spring"]},{"title":"Spring 注解驱动开发","url":"/2017/10/04/Spring 注解驱动开发/","content":"\n### 一、bean注册相关\n\n#### @Configuration\n\nJava Bean的配置来源标识，与XML配置异曲同工。\n\n#### @Bean \n\n具体bean配置，默认方法名称为Bean的name，可通过value指定多个BeanName\n\ninit-method、destroy-method指定初始化、销毁方法。\n\n#### @Scope\n\nbean在容器中的存在形式，默认singleton。（容器在初始化时进行预加载）\n\n可选类型：prototype（原型，每次请求获取的bean都是新创建的）、request、session\n\n#### @ComponentScan\n\n扫描注册类，定义bean扫描规则。\n\nvalue:指定扫描的包路径\n\nincludeFilters:指定扫描的时候按照什么规则包含哪些组件\n\nexcludeFilters:指定扫描的时候按照什么规则排除哪些组件\n\n其中includeFilters，excludeFilters可自定义过滤器，自定义过滤器需实现TypeFilter接口。\n\n#### @Lazy\n\n针对singleton而说，当加上该注解后，容器启动时不进行预加载，而是第一次应用索要bean时进行加载。\n\n#### @Conditional\n\n使用在类上或者方法上，定义bean的注册条件，条件规则器实现Condition接口。\n\n#### @Import\n\n快速给容器中导入组件,导入后在容器中组件的name 是导入组件的全类名。\n\n @Import(value={Color.class,MyImportSelector.class,MyImportBeanDefinitionRegistrar.class})\n\n三种类型的导入方法：\n\n- 导入具体组件的class类\n- 实现ImportSelector接口，导入该实现类，返回需要导入组件的全类名集合\n- 实现ImportBeanDefinitionRegistrar接口registerBeanDefinitions方法，在该方法内手动进行注册组件的BeanDefinition\n\n#### @ImportResource\n\n  导入beanDefinition定义的xml文件，即描述bean的xml文件\n\n#### 总结\n\n给容器中注册bean的方式：\n\n- @ComponentScan + @Controller、@Service、@Reporstory、@Componenet\n- @Bean 方式导入三方组件\n- @Import快速导入三方组件\n- @ImportResource 导入定义描述bean的xml文件\n\n### 二、bean生命周期相关\n\n#### 指定初始化和销毁方法\n\n@Bean指定init-method,destroy-method,单实例是在容器关闭时调用destroy方法，而多实例则不会管理这个bean销毁\n\n#### 实现spring bean生命周期相关接口\n\nbean 实现InitializingBean接口afterPropertiesSet 方法执行初始化，实现DisposableBean接口destroy方法进行销毁前的执行\n\n\n\n#### 使用JSR-250注解\n\n@PostConstruct、 @PreDestroy\n\n#### 实现BeanPostProcessor\n\n实现BeanPostProcessor，对所有bean创建后，init-method之前、之后对bean进行包装等操作。\n\n#### 实现xxxAware接口\n\nspring内部将进行值的回调设置。比如ApplicaitonContextAware,BeanNameAware,EmbeddedValueResolverAware\n\n\n\n### 三、bean依赖注入相关\n\n#### @Value\n\n- @Value(\"张三\")\n- @Value(\"#{20-2}\")\n- @Vaule(\"${}\") 读取配置文件中的值（在运行变量中的值）\n\n \n\n#### @PropertySource\n\n@PropertySource(\"classpath:/person.properties\") 将配置文件中的值导入环境变量\n\n#### @Autowired\n\n 默认按照组件的类型去匹配，类型匹配到多个然后按照name去匹配。默认必须可以找到匹配的值，可通过@Autowired(required = false)设置非必须注入，可标注在方法、属性、参数上\n\n#### @Qualifier\n\n指定匹配的模式按照bean的name匹配\n\n#### @Primary\n\nspring装配的时候默认使用首选的bean，当一个类型匹配多个实例后，优先级的选择。\n\n#### @Resource\n\nJSR-250提供，默认按照组件名称进行装配,@Resource(name=\"\")可指定name.但是没有按照类型同时按照优先级进行匹配\n\n#### @Inject\n\n#### @Profile\n\n@Profile(\"dev\")  自动装配环境搭建，默认default","tags":["spring"]}]